#!/usr/bin/env python3
"""
Lightweight Fulcrum/bitcoind monitor for Raspberry Pi.

Features:
- Reads config from local.env in same directory
- Tracks:
    - bitcoind chain height
    - Fulcrum "Processed height"
    - Lag, average speed, std-dev, ETA
- Monitors:
    - CPU %
    - RAM %
    - SSD temperature (if accessible)
- Automatic stall recovery:
    - If Fulcrum height doesn't move for > STALL_THRESHOLD, restart fulcrum service
- Writes PNG charts:
    - speed_chart.png (Fulcrum indexing speed)
    - system_chart.png (CPU/RAM/SSD temp)
- Console + log file output
- Optional Telegram integration
"""

import os
import time
import subprocess
import re
from pathlib import Path

import psutil
from dotenv import load_dotenv

import matplotlib
matplotlib.use("Agg")  # no GUI
import matplotlib.pyplot as plt

from logger_util import Logger
from telegram_client import TelegramClient
from speed_tracker import SpeedTracker
from system_helpers import get_ssd_temp, write_system_chart

# ---------------------------------------------------------------------
# Paths & config loading
# ---------------------------------------------------------------------

BASE_DIR = Path(__file__).resolve().parent
ENV_FILE = BASE_DIR / "local.env"
LOG_FILE = BASE_DIR / "monitor.log"
SPEED_CHART_FILE = BASE_DIR / "speed_chart.png"
SYSTEM_CHART_FILE = BASE_DIR / "system_chart.png"

logger = Logger(LOG_FILE)

if ENV_FILE.exists():
    load_dotenv(ENV_FILE)
else:
    logger.log(f"[WARN] {ENV_FILE} not found. Using defaults + hard-coded paths.")

BOT_TOKEN = os.getenv("BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")
ENABLE_TELEGRAM = os.getenv("ENABLE_TELEGRAM", "0") == "1"
ENABLE_AUTO_RESTART = os.getenv("ENABLE_AUTO_RESTART", "0") == "1"

tg = None
if ENABLE_TELEGRAM and BOT_TOKEN and CHAT_ID:
    tg = TelegramClient(BOT_TOKEN, CHAT_ID, logger)


def log(msg: str):
    """Convenience wrapper so old code can keep using log()."""
    logger.log(msg)


def parse_duration(value, default_seconds):
    """
    Parse strings like '30', '30s', '5m', '2h' into seconds.
    """
    if not value:
        return default_seconds
    s = value.strip().lower()
    if s.endswith("s"):
        try:
            return int(s[:-1])
        except ValueError:
            return default_seconds
    if s.endswith("m"):
        try:
            return int(s[:-1]) * 60
        except ValueError:
            return default_seconds
    if s.endswith("h"):
        try:
            return int(s[:-1]) * 3600
        except ValueError:
            return default_seconds
    try:
        return int(s)
    except ValueError:
        return default_seconds


BITCOIN_CONF = os.getenv("BITCOIN_CONF", "/mnt/bitcoin/bitcoind/bitcoin.conf")
FULCRUM_SERVICE = os.getenv("FULCRUM_SERVICE", "fulcrum")
BITCOIND_SERVICE = os.getenv("BITCOIND_SERVICE", "bitcoind")

CHECK_INTERVAL = parse_duration(os.getenv("CHECK_INTERVAL", "120"), 120)
STALL_THRESHOLD = parse_duration(os.getenv("STALL_THRESHOLD", "1800"), 1800)  # 30m
SPEED_WINDOW = int(os.getenv("SPEED_WINDOW", "50"))

SSD_TEMP_THRESHOLD = float(os.getenv("SSD_TEMP_THRESHOLD", "65"))
CPU_ALERT_THRESHOLD = float(os.getenv("CPU_ALERT_THRESHOLD", "90"))
RAM_ALERT_THRESHOLD = float(os.getenv("RAM_ALERT_THRESHOLD", "90"))

CHART_INTERVAL = parse_duration(os.getenv("CHART_INTERVAL", "3600"), 3600)  # 1h

speed_tracker = SpeedTracker(window=SPEED_WINDOW)

# ---------------------------------------------------------------------
# Helper functions to query system state
# ---------------------------------------------------------------------

def get_bitcoind_height():
    try:
        out = subprocess.check_output(
            [
                "sudo", "-u", "bitcoin",
                "/usr/local/bin/bitcoin-cli",
                f"-conf={BITCOIN_CONF}",
                "getblockcount",
            ],
            stderr=subprocess.DEVNULL,
        )
        return int(out.strip())
    except Exception as e:
        log(f"[ERR] get_bitcoind_height failed: {e}")
        return None


def get_fulcrum_height(last_seen_height=None):
    """
    Parse last 'Processed height: XXXX' from fulcrum journald logs.

    Returns:
      (height, is_new)
        - height: int or None
        - is_new: True if this is strictly greater than last_seen_height
    """
    try:
        out = subprocess.check_output(
            ["sudo", "journalctl", "-u", FULCRUM_SERVICE, "--no-pager"],
            stderr=subprocess.DEVNULL,
        ).decode()
        matches = re.findall(r"Processed height:\s*([0-9]+)", out)
        if not matches:
            return None, False
        height = int(matches[-1])
        is_new = last_seen_height is None or height > last_seen_height
        return height, is_new
    except Exception as e:
        log(f"[ERR] get_fulcrum_height failed: {e}")
        return None, False


# ---------------------------------------------------------------------
# Stall recovery
# ---------------------------------------------------------------------

def restart_fulcrum():
    if not ENABLE_AUTO_RESTART:
        log("[STALL] Auto-restart disabled (ENABLE_AUTO_RESTART=0). Not restarting fulcrum.")
        return
    try:
        log("[RECOVERY] Restarting fulcrum via systemctl...")
        subprocess.check_call(["sudo", "systemctl", "restart", FULCRUM_SERVICE])
        log("[RECOVERY] fulcrum restart triggered.")
        if tg:
            tg.send_text("â™»ï¸ Fulcrum restart triggered by monitor.")
    except Exception as e:
        log(f"[ERR] Failed to restart fulcrum: {e}")


# ---------------------------------------------------------------------
# Main loop
# ---------------------------------------------------------------------

def main():
    log("========== Fulcrum monitor starting ==========")
    log(f"BITCOIN_CONF={BITCOIN_CONF}")
    log(f"CHECK_INTERVAL={CHECK_INTERVAL}s, STALL_THRESHOLD={STALL_THRESHOLD}s")
    log(f"SSD_TEMP_THRESHOLD={SSD_TEMP_THRESHOLD}Â°C, CPU_ALERT={CPU_ALERT_THRESHOLD}%, RAM_ALERT={RAM_ALERT_THRESHOLD}%")
    log(f"Charts every {CHART_INTERVAL}s (approx).")

    if tg:
        tg.send_text("ðŸš€ Fulcrum monitor started on knots00.")

    last_height_change_time = None
    last_fulcrum_height = None       # last height seen (even if reused)
    last_new_fulcrum_height = None   # last strictly increasing height
    last_chart_time = 0
    last_recovery_time = 0
    MIN_RECOVERY_INTERVAL = 600  # 10 min, to avoid restart flapping

    while True:
        loop_start = time.time()

        btc_height = get_bitcoind_height()
        ful_height, is_new = get_fulcrum_height(last_new_fulcrum_height)

        if btc_height is None or ful_height is None:
            log("[WARN] Could not read heights (bitcoind or fulcrum).")
        else:
            lag = btc_height - ful_height

            # Only update speed if Fulcrum actually advanced
            if is_new:
                speed_tracker.update(ful_height)
                last_new_fulcrum_height = ful_height

                ema_speed, stdev = speed_tracker.get_stats()
                # ETA from current EMA
                if ema_speed is not None and ema_speed > 0:
                    eta_sec = lag / ema_speed
                    eta_hours = eta_sec / 3600.0
                    eta_str = f"{eta_hours:.2f} h"
                else:
                    eta_str = "N/A"

                speed_str = f"{ema_speed:.3f}" if ema_speed is not None else "N/A"
                stdev_str = f"{stdev:.3f}" if stdev is not None else "N/A"

                log(
                    f"Heights: bitcoind={btc_height}, fulcrum={ful_height}, "
                    f"lag={lag} blocks, speed~={speed_str} blk/s (Ïƒ={stdev_str}), ETA={eta_str}"
                )

                # reset stall timer on progress
                last_height_change_time = loop_start
            else:
                # No new Fulcrum height; only initialise stall timer if needed.
                if last_height_change_time is None:
                    last_height_change_time = loop_start

            # stall detection
            if last_height_change_time is not None:
                stalled_for = loop_start - last_height_change_time
                if stalled_for > STALL_THRESHOLD:
                    now = loop_start
                    if now - last_recovery_time > MIN_RECOVERY_INTERVAL:
                        log(
                            f"[STALL] Fulcrum height unchanged for "
                            f"{stalled_for:.0f}s (> {STALL_THRESHOLD}s)."
                        )
                        if tg:
                            tg.send_text(
                                f"âš ï¸ Fulcrum stall: height={ful_height}, "
                                f"stalled_for={stalled_for:.0f}s. Considering restart..."
                            )
                        restart_fulcrum()
                        last_recovery_time = now
                    else:
                        log("[STALL] Stall detected but recovery recently done; skipping restart.")

        # system stats
        try:
            cpu_pct = psutil.cpu_percent(interval=1)
            ram_pct = psutil.virtual_memory().percent
        except Exception as e:
            log(f"[ERR] psutil error: {e}")
            cpu_pct = None
            ram_pct = None

        ssd_temp = get_ssd_temp()

        if cpu_pct is not None and cpu_pct > CPU_ALERT_THRESHOLD:
            log(f"[ALERT] CPU high load: {cpu_pct:.1f}%")
            if tg:
                tg.send_text(f"âš ï¸ High CPU load: {cpu_pct:.1f}%")

        if ram_pct is not None and ram_pct > RAM_ALERT_THRESHOLD:
            log(f"[ALERT] RAM high usage: {ram_pct:.1f}%")
            if tg:
                tg.send_text(f"âš ï¸ High RAM usage: {ram_pct:.1f}%")

        if ssd_temp is not None and ssd_temp > SSD_TEMP_THRESHOLD:
            log(f"[ALERT] SSD temperature high: {ssd_temp:.1f}Â°C")
            if tg:
                tg.send_text(f"âš ï¸ SSD temperature high: {ssd_temp:.1f}Â°C")

        # charts occasionally
        now = time.time()
        if now - last_chart_time > CHART_INTERVAL:
            if speed_tracker.samples:
                # Speed chart (Fulcrum indexing speed)
                try:
                    plt.figure(figsize=(10, 4))
                    plt.plot(speed_tracker.samples, marker="o", linestyle="-")
                    plt.title("Fulcrum Indexing Speed (blocks/sec)")
                    plt.xlabel("Sample index (last N checks)")
                    plt.ylabel("blocks/sec")
                    plt.grid(True)
                    plt.tight_layout()
                    plt.savefig(SPEED_CHART_FILE)
                    plt.close()
                    log(f"[CHART] Wrote speed chart to {SPEED_CHART_FILE}")
                except Exception as e:
                    log(f"[ERR] Failed to write speed chart: {e}")
            if cpu_pct is not None and ram_pct is not None:
                write_system_chart(cpu_pct, ram_pct, ssd_temp, SYSTEM_CHART_FILE, logger)
            last_chart_time = now

        # sleep until next interval
        elapsed = time.time() - loop_start
        remaining = CHECK_INTERVAL - elapsed
        if remaining > 0:
            time.sleep(remaining)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        log("Monitor interrupted by user, exiting.")
